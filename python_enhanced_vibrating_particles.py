# -*- coding: utf-8 -*-
"""PYTHON_ENHANCED_VIBRATING_PARTICLES.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uotSyl9jhw5hxTOo8ZayL2EipialvoJ-

#**Initialize Variable**
"""

import numpy as np
import random

popSize=50  #Size of the population
nVar=4;     # Number of optimization variables
maxIt=1000; # Maximum number of iteration
xMin=-100;  # Lower bound of the variables
xMax=100;   # Upper bound of the variables
alpha=0.05;
w1=0.3;
w2=0.3;
w3=1-w1-w2;
p=0.2;      # With the probability of (1-p) the effect of BP
#is ignored in updating
PAR=0.1;
HMCR=0.95;
Memorysize=4;

"""#**Parameter**"""

result=np.zeros((popSize,nVar+1))
Memory=np.zeros((Memorysize,nVar+1))
neighbor=0.1 #Parameters for handling the side
#constraints
#Initializing particles
position = xMin+ np.random.rand( popSize,nVar) * (xMax-xMin)
print(position.shape)
print(position)

import math
def SphereFun(x):
  #If there is any violation:
  #Penalty=sum of violations
  #CP=Coefficient of penalty
  #penalizedWeight=sum(x.^2)*(1+CP*Penalty);
  penalizedWeight=(math.pow(np.array(x[0]),2))+(math.pow(np.array(x[1]),2))+(math.pow(np.array(x[2]),2))+(math.pow(np.array(x[3]),2))
  #weight=sum(math.pow(np.array(x),2))
  return penalizedWeight

#YOUR_LIST=[1  2 3   4]
#a=np.array(YOUR_LIST)
print(position[1,:])
b=list(position[1,:])
#print(list(position[1,:]))
#print(math.pow(position[1,:],2))
print(math.pow(position[1,1],2))

#Search
agentCost=np.zeros((popSize,3)) #Array of agent costs
HBV=np.zeros((popSize,nVar+2))       # Historically best matrix
m=0
iter=0
a=np.zeros((1,4))       # Historically best matrix
for iter in range(maxIt):
  #Evaluating and storing
  for m in range(popSize-1):
    penalizedWeight=SphereFun(position[m,:])
    weight=SphereFun(position[m,:])
    agentCost[m,0]=penalizedWeight
    agentCost[m,1]=m
    agentCost[m,2]=weight


  sortedAgentCost=agentCost.sort()
  for m in range(popSize-1):
    if iter==1 or agentCost[m,0]<HBV[m,0]:
      HBV[m,0]=agentCost[m,0];
      HBV[m,1]=agentCost[m,2];
      for n in range(nVar):
        HBV[m,n+1]=position[m,n]
  HBV.sort()
  result[iter,1]=HBV[1,1]
  result[iter,2:nVar+1]=HBV[1,3:nVar+2]

# Commented out IPython magic to ensure Python compatibility.
 weight=SphereFun(position[m,:])
    #Evaluating the objective function for each particle
    agentCost[m,1]=penalizedWeight
    agentCost[m,2]=m
    agentCost[m,3]=weight



sortedAgentCost=sortrows(agentCost);
for m in popSize:
if iter==1 || agentCost(m,1)<HBV(m,1)
HBV(m,1)=agentCost(m,1);
HBV(m,2)=agentCost(m,3);
for n=1:nVar
HBV(m,n+2)=position(m,n);
end
end
end
sortedHBV=sortrows(HBV);
result(iter,1)=sortedHBV(1,1);
result(iter,2:nVar+1)=sortedHBV(1,3:nVar+2);
if iter==1
 for i=1:Memorysize
 Memory(i,1)=sortedHBV(i,1);
 Memory(i,2:nVar+1)=sortedHBV(i,3:nVar+2);
 end
end
if Memory(Memorysize,1)>sortedHBV(1,1)
 Memory(Memorysize,1)=sortedHBV(1,1);
 Memory(Memorysize,2:nVar+1)=sortedHBV(1,3:nVar+2);
end
Memory=sortrows(Memory);
# % Updating particle positions
D=(iter/maxIt)^(-alpha);
for m=1:popSize
temp1=ceil(unifrnd(1,popSize/2,1));
temp2=ceil(unifrnd(popSize/2,popSize,1));
temp11=round(unifrnd(1,Memorysize,1));
 if p<rand
 w3=0;
 w2=1-w1;
 end
 for n=1:nVar
 if rand<w3
 A(m,n)=(-1)^(ceil(randn()))*(position(sortedAgentCost(temp2,2),n)-position(m,n));
position(m,n)=D*A(m,n)*rand+position(sortedAgentCost(temp2,2),n);
 elseif rand<w2
 A(m,n)=(-1)^(ceil(randn()))*(position(sortedAgentCost(temp1,2),n)-position(m,n));
position(m,n)=D*A(m,n)*rand+position(sortedAgentCost(temp1,2),n);
 else
 A(m,n)=(-1)^(ceil(randn()))*(Memory(temp11,1+n)-position(m,n));
 position(m,n)=D*A(m,n)*rand+Memory(temp11,1+n);
 end
end
w2=0.3;w3=1-w1-w2;
end
# % Handling the side constraints
for m=1:popSize
 for n=1:nVar
if position(m,n)<xMin || position(m,n)>xMax
temp1=rand;temp2=rand;temp3=ceil(rand*popSize);
if temp1<=HMCR && temp2<=(1-PAR)
position(m,n)=sortedHBV(temp3,2+n);
elseif temp1<=HMCR && temp2>(1-PAR)
position(m,n)=sortedHBV(temp3,2+n)+neighbor;
if position(m,n)>xMax
position(m,n)=sortedHBV(temp3,2+n)-2*neighbor;
end
else
position(m,n)=xMin+(rand*(xMax-xMin));
end
end
end
end
iter
sortedHBV(1,1)
end
# % Saving the results
xlswrite('result.xls',result);